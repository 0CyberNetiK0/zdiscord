/**
 * This file is part of zdiscord.
 * Copyright (C) 2021 Tony/zfbx
 * source: <https://github.com/zfbx/zdiscord>
 *
 * zdiscord is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * zdiscord is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with zdiscord. If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU'RE DOING OR ARE
 * SUGGESTED TO DO SO BY SOMEONE WHO DOES. <3
 */

const fetch = require("node-fetch");
const root = GetResourcePath(GetCurrentResourceName());
const config = require(`${root}/config`);
const locale = require(`${root}/locales/${config.LanguageLocaleCode}`);
const utils = require(`${root}/server/utils`);
const Bot = require(`${root}/server/bot`);
loadDiscordPermissions();

let bot = false;
if (config.EnableDiscordBot) {
    bot = new Bot(config, utils, locale);
    bot.start();
}

SetConvarReplicated("zdiscord_servername", config.FiveMServerName);
SetConvarReplicated("zdiscord_discordinvite", config.DiscordInviteLink);
SetConvarReplicated("zdiscord_serverip", config.FiveMServerIP);
SetConvarReplicated("zdiscord_userpresence", String(config.enableUserPresence));

on("playerConnecting", async (name, setKickReason, deferrals) => {
    const player = source;
    if (!config.EnableWhitelistChecking || !config.EnableDiscordBot) return;
    deferrals.defer();
    await utils.sleep(0);
    deferrals.update(utils.replaceGlobals(locale.checkingWhitelist.replace(/{name}/g, name)));
    await utils.sleep(0);
    const discordID = utils.getPlayerDiscordId(player);
    if (!discordID) return deferrals.done(utils.replaceGlobals(locale.discordNotOpen));
    const member = utils.getMember(bot, discordID);
    if (!member) return deferrals.done(utils.replaceGlobals(locale.notInDiscordServer));
    const whitelisted = utils.isRolePresent(bot, member, config.DiscordWhitelistRoleIds);
    if (whitelisted) deferrals.done();
    else deferrals.done(utils.replaceGlobals(locale.notWhitelisted));
});

global.exports("isRolePresent", (identifier, role) => {
    if (!config.EnableDiscordBot) return false;
    return utils.isRolePresent(bot, identifier, role);
});

global.exports("getRoles", (identifier) => {
    if (!config.EnableDiscordBot) return false;
    return utils.getMemberRoles(bot, identifier);
});

global.exports("getName", (identifier) => {
    if (!config.EnableDiscordBot) return false;
    const member = utils.parseMember(bot, identifier);
    return member.displayName || false;
});

on("playerJoining", (oldId) => {
    const source = global.source;
    if (!config.EnableDiscordBot) return;
    const member = utils.getMemberFromSource(bot, source);
    if (config.EnableAutoAcePermissions) {
        for (const [perm, role] of Object.entries(config.AutoAcePermissions)) {
            if (utils.isRolePresent(bot, member, role)) {
                ExecuteCommand(`add_principal "player.${source}" "${perm}"`);
            }
        }
    }
    if (utils.isRolePresent(bot, member, [ config.DiscordModRoleId, config.DiscordAdminRoleId, config.DiscordGodRoleId ])) {
        ExecuteCommand(`add_principal "player.${source}" "zdiscord.staffchat"`);
    }
});

on("playerDropped", (reason) => {
    const source = global.source;
    if (!config.EnableDiscordBot) return false;
    if (config.EnableAutoAcePermissions) {
        for (const [perm, role] of Object.entries(config.AutoAcePermissions)) {
            ExecuteCommand(`remove_principal "player.${source}" "${perm}"`);
        }
    }
});

const staffChatDisabled = {};

if (config.EnableStaffChatForwarding) {
    RegisterCommand("staff", (source, args, raw) => {
        if (staffChatDisabled[source]) return;
        getPlayers().forEach(async function(player, index, array) {
            if (IsPlayerAceAllowed(player, "zdiscord.staffchat") && !staffChatDisabled[player]) {
                emitNet("chat:addMessage", player, {
                    template: `<div class=chat-message server'><strong>[staff] ${GetPlayerName(source)}:</strong> ${raw}</div>`,
                });
            }
        });
        if (!config.EnableDiscordBot) return;
        const staffChannel = bot.channels.cache.get(config.DiscordStaffChannelId);
        if (!staffChannel) return utils.log.warn("DiscordStaffChannelId was not found, staff message not sent.");
        staffChannel.send({ content: `${GetPlayerName(source)}: ${raw}`, allowMentions: false });
    }, "zdiscord.staffchat");

    RegisterCommand("stafftoggle", (source, args, raw) => {
        if (staffChatDisabled[source]) {
            staffChatDisabled[source] = false;
            emitNet("chat:addMessage", player, {
                template: "<div class=chat-message server'><strong>[server]:</strong> Staff Chat Enabled</div>",
            });
        } else {
            staffChatDisabled[source] = true;
            emitNet("chat:addMessage", player, {
                template: "<div class=chat-message server'><strong>[server]:</strong> Staff Chat Disabled</div>",
            });
        }
    }, "zdiscord.staffchat");

    setImmediate(() => {
        emit("chat:addSuggestion", "/staff", "Send message to other staff (Staff only)", [
            { name:"Message", help:"Message to send to other staff" },
        ]);
        emit("chat:addSuggestion", "/stafftoggle", "Toggle staff chat messages", []);
    });
}

/** Sends a log through to a webhook by name configured in config
 * @param {string} type - type of log/event to pick which webhook to send
 * @param {string} message - Message to log
 * @param {boolean} pingRole - Whether message should ping configured role
 * @param {string|number} color - [optional] color to have on the embed
 * @returns {boolean} - success or failure of logging event */
global.exports("log", async (type, message, pingRole, color) => {
    if (config.EnableLoggingWebhooks) {
        if (!message || !type) {
            utils.log.error("[WEBHOOK FAIL] Log without message or type not permitted");
            return false;
        }
        if (!config.LoggingWebhooks[type]) {
            utils.log.error(`[WEBHOOK FAIL] "${type}" is not defined. Message: ${message}`);
            return false;
        }
        const params = {
            username: config.LoggingWebhookName,
            embeds: [
                {
                    "description": message,
                    "color": "#1e90ff",
                },
            ],
        };
        if (pingRole) params.content = `<@&${config.LoggingAlertPingRoleId}>`;
        const reply = await fetch(config.LoggingWebhooks[type], {
            method: "POST",
            headers: { "Content-type": "application/json" },
            body: JSON.stringify(params),
        });
        if (!reply.ok) {
            utils.log.error(`[WEBHOOK FAIL] ${type.toLowerCase()} log failed. Message: ${message}. Error: ${reply.status}`);
            return false;
        }
        return true;
    }
    return false;
});

/** Generates permissions for commands to inherit from */
function loadDiscordPermissions() {
    const mod = { id: config.DiscordModRoleId, type: 1, permission: true };
    const admin = { id: config.DiscordAdminRoleId, type: 1, permission: true };
    const god = { id: config.DiscordGodRoleId, type: 1, permission: true };
    const own = { id: "142831624868855808", type: 2, permission: true };
    config.perms = {
        "mod": [ mod, admin, god, own ],
        "admin": [ admin, god, own ],
        "god": [ god, own ],
    };
}
